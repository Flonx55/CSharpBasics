# 复习简答题 

#### 1、c#语言经编译后得到的是什么指令？

Microsoft 中间语言指令

#### 2、简述c#源程序的组成部分以及程序代码的基本执行过程

公共语言运行规范（CLS）+公共语言运行时（CLR）+.Net Framework+ 编译器+开发工具

先编译成中间语言（IL），在第一次运行时，会即时再编译（JIT）成机器语言。所以第一次相对要慢一点

#### 3、简述字符、枚举和整数的关系

枚举可以将字符收集整理，调用的时候只需整数类型的”下标“ 

#### 4、什么情况下使用结构，什么情况下使用枚举？

==枚举一般用来表示状态，一个物体有N种状态，但某一个时刻只具有其中一种状态，表示的内容单一。==例如月份，星期，颜色。c#的枚举也支持多个值相合并，需要添加Flag标志。

枚举可以看作是一种整型数值类型，可以看作是整型数值类型的常量。不过使用起来比常量更直观方便一些。

==结构用来表示一组状态==，例如表示一个人，具有姓名、性别、身高等等，有点与==类声明多个字段==相似。多用来传递数据。

#### 5、简述值类型和引用类型的区别

##### 简述1

对于值类型，==其变量直接包含自身的所有数据，每创建一个新变量，就在内存中单独开辟一块区域==；

对于引用类型，==每个变量只存储对目标数据的引用，每创建一个变量，就增加一个指向目标数据的指针==。	

##### 简述2

值类型==直接存放实际数据==，==每个值类型都有自己固定的长度==，比如int类型占用4个字节。==值类型的变量保存在堆栈==（stack），堆栈用于存储固定长度的数据。==对一个值类型变量操作不会影响其他变量==。值类型的内存开销小，访问速度快，==但缺乏面向对象特征==

引用类型==存储的是数据的内存地址==，位于==受管制的堆==（ManageHeap）上。堆用于存储可变长度的数据，比如字符串类型。当声明引用类型变量时,程序只是分配了存放这个引用的存储空间.要想创建对象并把对象的存储地址赋给该变量,就需要用到new操作符. 作为引用类型的变量可能引用同一对象，因此==对一个引用类型的变量操作会影响引用相同对象的另一个变量==。引用类型因在堆上分配内存，内存开销大，访问速度稍慢。

==特殊值null适用于任何引用类型，表示没有任何引用的对象。但值类型不能是null。==

#### 6、可否将一个枚举类型的数组转换成一个整数数组？如可以，使用的是哪种转换？

可以。显示转换

#### 7、能否将元素类型分别为Int、float和double的3个数组放在同一个多维数组中？

不可以

#### 8、如何删除一个字符串的所有空格？

使用Trim（）可以去掉字符串前后的空格

```
string myString = "This is a test";
Console.WriteLine(myString.Trim());
```

使用Replace（）函数可以去掉字符串中间及前后的空格

string myString = "  this is a test ";

console.writeline(myString.Replace(" ".""));

```
string myString = "This is a Test";
Console.WriteLine(myString.Replace(" ",""));
```

#### 9、在c#程序中定义变量名有什么规定？

c#语言要求变量名的名称必须==以字母开头，并由字母、数字和下划线==或@字符构成，而且不能与c#中的==关键字或库函数==的名称（如using、int、Main等）相同。

#### 11、简述局部变量和成员字段在用法上的相同点和不同点

成员字段是通用于==整个类成员函数==。

成员字段==在定义时必须明确其类型，而不能使用var进行隐式定义。==

成员字段==可以在类存在期间保持它的取值。==

如果未采用任何一种方式为字段指定初始值，那么在创建对象后，==字段将取其类型的默认值null。==



局部变量仅适用于==当前函数==，比如类成员函数，出了这个函数就失效了

局部变量==如果没有声明是static的一般都无法保持取值，随函数的退出而被释放。==

而对于局部变量==所赋值的所有的整数（包括字符和枚举）类型和实数类型，其默认值为0；布尔类型的默认值为====false。==

#### 12、常数字段和只读字段有何不同？

1、赋值方法不同

​	==常数字段只能在声明的时候赋值，常数字段的值是在编译时确定的，编译时只可计算==

​	==只读字段除了其所属的类或结构的构造函数，不允许在其他任何地方修改其值==

2、类型不同

​	==常数字段一般都是简单值类型或字符串类型==

​	==只读字段既可以是值类型，也可以是引用类型==

#### 13、方法的返回值和输出型参数有什么区别？他们各自适用于什么场合？

==返回值只有一个，固定的类型。输出参数可以有多个，每个是不同的类型，只要加上out关键字就可以了==

==1、在函数需要返回单个值类型时，用return==

==2、在函数需要返回多个值类型时，修改函数，返回单个值类型==	

==3、在函数需要返回引用类型时，如果函数要频繁调用，并且返回类型的创建又很复杂时，用输出型函数==

#### 14、当操作数均为bool类型时，位运算表达式和条件逻辑表达式之间有什么关系？

==逻辑与、或、非对布尔类型的操作数的运算效果和位运算中的与、或、取反运算效果相同==

#### 15、as类型转换操作与is类型操作有何不同？和一般类型转换操作又有何不同？

==as在转换的同时兼判断兼容性，is只是做类型兼容判断==，并不执行真正的类型转换。==is返回True或false==，不会返回null，对象为null也会返回false。

==as运算符只能进行引用类型的转换或装箱转换，而不能在两个值类型之间进行转换。如果是值类型只能结合is来强制转换。==

==as运算符在遇到无法转换的情况下不会抛出异常，而是返回null值==

==一般的用小括号语法的强制类型转换时如果类型不匹配就会抛出异常==

#### 16、在进行条件选择时，if……else语句和switch语句各有什么特点？

==switch 语句可以一次将测试变量与多个值进行比较，而不是仅测试一个条件==

如果==控制表达式的取值范围较小且离散分布明显，使用switch语句可提高程序的可读性；==

如果==取值范围较大或是存在区间分布，那么使用if语句更有利于简化程序==。

#### 17、对于多重嵌套循环，能否通过内层循环中的代码来跳出外层循环？

1、可以通过goto跳出循环

2、设定一个bool类型的标记量，当满足条件时改变这个标记量的值，循环的地方这个标记量作为循环的执行条件之一，不满足就不继续循环了，从而跳出循环，while这种就是典型。

#### 18、一个类是否可以有多个构造函数和析构函数？

==析构函数是自动调用的，不存在重载的可能，所以只有一个析构函数。==

==而构造函数可以根据传入参数进行重载==

#### 19、类的属性和字段有什么不同？和一般的方法又有什么不同？

类的字段准确地说应该是==类的数据成员==，==用于存储类和类的实例相关数据的变量==

属性是一个代表类的实例或类中的一个数据项的函数成员,用来保护和限定字段。在类的属性中对字段进行赋值和取值可以用两个访问器set（）和get（）来实现

方法就是类的函数成员，是一个为实现类的某一个特定功能的函数。

方法和属性最大的区别是==属性没有参数列表==，==而方法必须要有参数列表，哪怕没有参数，也要放一个空括号在那。==其次，==属性定义里要有set（）和get（）两个访问器，用于赋值和取值。==

#### 20、c#中那些操作符是不能被重载的？

```
=`, `.`, `?:`, `??`, `->`, `=>`, `as`, `checked`, `unchecked`, `default`, `delegate`, `is`, `new`, `sizeof`, `typeof
```

#### 21、如何将一个事件关联多个事件处理方法？如何使多个事件使用一个事件处理方法？

继承

多态-虚方法，抽象类，接口

#### 22、在类的静态方法代码中能否使用this对象引用，为什么？

==this指的是类实例化的当前对象==，静态方法是==通过类调用的==，不需要实例化；

既然==不需要实例化，就没有当前对象==；既然没有当前对象，就不能使用this关键字

this的用法

1、this代表类实例化的当前对象

2、用this串联构造函数

3、为原始类型拓展方法

4、索引器

```
public class Person    
{                 
	public string personName;        
    public int personAge;         //定义年龄为可空类型,这样就可以赋予其null值  
	//下面前三个构造函数都是去调用参数最多的第四个构造函数,只取它们所需要的部分参数即可         
	//这样的做法就是this串联构造函数
    public Person():this("",0)   
    {
    }        
    public Person(string name):this("evan",null)         
    {
    }  
    public Person(int age):this("",20)   
    {
    } 
    public Person(string name, int age) 
    {       
    	this.personName = name;         
        //通过 ?? 判断传入的age是否null值     
        //如果属于null值,则赋值100     
        //变量定义中含有一个问号，意思是这个数据类型是NullAble类型的。
 		//变量定义中含有两个问号，意思是取所赋值??左边的，如果左边为null，取所赋值??右边的
        this.personAge = age ?? 100;        
    }  
    public void Display()  
    {           
    	Console.WriteLine("Name:{0},Age:{1}\n", personName, personAge);         }         }
```



#### 23、举例说明派生类对基类成员的覆盖和重载有什么区别。

当两个独立的函数具有相同的函数名但有不同的函数签名（即参数的类型，数量及顺序），他们的关系就是重载，派生类对基类成员函数的覆盖严格来讲是对基类成员函数的重新定义，即重写，它们的函数签名可以相同也可以不同。

#### 24、简述base关键字和this关键字之间的区别。

base关键字：主要是应用于类的继承，可以在子类的构造函数、方法、实例属性中引用父类中的公有以及受保护的方法、字段、属性、索引器等

this关键字：主要是引用当前实例或者继承的方法

#### 25、简述虚拟方法和抽象方法的相同点和不同点

不同点：

1、方法关键字不一样

​	虚方法的方法关键字是virtual

​	抽象类的方法关键字是abstract

2、基类的方法是否有方法体实现

​	虚方法的方法：声明并实现方法

​	抽象类的方法：只作声明，无方法体实现

共同点：

1、==子类和派生类都要重写父类的方法==：关键字override

#### 26、简述抽象类和接口的相同点和不同点。

相同点：都不可以实例化，都可以通过继承实现其抽象方法

不同点：接口支持多继承，抽象类不能实现多继承

接口只定义抽象规则；抽象类既可以定义抽象规则，还可以提供以实现的成员

接口可用于回调，抽象类不能实现回调

接口只包含方法、属性、索引器、事件的签名，但是==不能定义字段和包含实现的方法==；抽象类可以定义字段、属性、包含有实现的方法

==接口可以作用于值类型和引用类型；抽象类只能作用于引用类型==





# 基础零碎知识点

## 多维数组

#### 1、int[,]和int[] []的区别

<img src="C:\Users\86182\AppData\Roaming\Typora\typora-user-images\image-20201119193724578.png" alt="image-20201119193724578" style="zoom: 67%;" />

## 字符串

#### 1、使字符串可写的方法

##### 	1)ToCharArray()方法

```
string myString = "A string";
char[] mychars = myString.ToCharArray();
mychars[3] = 'a';
foreach (char character in mychars)//可以按照标准方式处理char数组
{
	Console.Write($"{character}");
}	

```



##### 	2）Trim()方法

```
string myString = " A string";
myString = myString.Trim(new char[] { ' ' });//有用
myString.Trim(new char[] { ' ' });			 //无用
```

Tip:

​	(1)==这几个命令并未真正改变应用它的字符串.把这个命令与字符串结合使用,就会创建一个新的字符串,以便与另一个字符串进行比较,或者赋值给另一个变量.该变量可以是当前操作的其他变量.==

下面为与其他字符串进行比较的案例:

```
string userResponse = Conosole.ReadLine();
if(userResponse.ToLower()=="Yes")			 //有用
{
	
}
userResponse = userResponse.ToLower();		 //有用
userResponse.ToLower();						 //无用
```

​	(2)<string>.TrimStart()和<string>.TrimEnd()-------删除字符串前后的空格

​		<string>.PadLeft()   和<string>.PadRight()-------在字符串前后添加空格------>适合在列中对齐字符串

```
<string>.PadX(<desireLength>);
ex:
myString = "Aligned";
myString = myString.PadLeft(10);
myString = myString.PadLeft(10,'-');
```

![image-20201119204005479](C:\Users\86182\AppData\Roaming\Typora\typora-user-images\image-20201119204005479.png)

![image-20201119204142803](C:\Users\86182\AppData\Roaming\Typora\typora-user-images\image-20201119204142803.png)

 

## 流程控制

●选择结构

●循环结构

●跳转结构

#### 1、选择结构

●if语句

●switch语句

#### 2、循环结构

●while

●do-while

●for

●foreach：对集合中的每一个元素执行循环体

#### 3、跳转结构

●break；跳出当前循环，转到循环结束

●continue：跳出本次循环，继续下次循环

●return:方法返回,如在循环中则终止循环

●goto:无条件转移

==1.编程计算菲波那契（Fibonacci）数列==

==2.随便输入一个字符串，判断特定字符子串出现的次数。==

==3.判断一个正整数是否为素数，如不是则输出其所有约数==

## 数据类型

#### 1、简单类型和复杂类型的区别：

- 基本类型又叫做值类型，复杂类型又叫做引用类型

- 值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。

- 引用类型：复杂数据类型，在存储是，变量中存储的仅仅是地址（引用），因此叫做引用数据类型。

  

### 值类型

#### 1、float

​	float,int这种类型只是C#的语法糖而已，在.NET框架中他du们是Single，Int32等等
因此，Convert.ToFloat实际上是Convert.ToSingle

《CLR via C#》的作者推荐永远不要使用int,short,float,等等，而是使用Int32,Int16,Single这些原生类型，这样在跨语言编程时才不会由于某种特定语言的特性而都不同类型产生迷惑 

### 引用类型

#### 0、对于引用类型

引用类似于C++中的对象指针。但又有区别：

●在C#中”引用“是指向一个对象在内存中的位置，在本质上是一种带有很强的完整性和安全性的限制的指针。
●当声明某个类、接口或数组类型的一个变量时，变量的值总是某个对象的引用或者是null引用。
●指针就是简单的地址而已，而引用除了表示地址而外，还是被引用的数据对象的缩影，可以提供其他信息。
●指针可以有++、--运算，引用不可以运算。



#### 1、类

●类是一个样板，以操作、表示和算法的形式完整地定义了一组对象的行为。它通常也是面向对象语言中的模块化、封装和数据抽象的基础。

●对象是类的一个实例，是一个软件单元，它由一组结构化的数据和在其上的一组操作构成。	

●C#所有的代码都在某一个类中，因此不可能在类之外的全局区域有变量和方法

●C#中的对象相当于一块内存区域，保存对象所特有的类中所定义的数据。





#### 2、数组

●数组是同一数据类型的一组值

●数组属于引用类型，因此存储在==堆内存中==

●数组元素初始化或给数组元素赋值都可以在声明数组时或在程序的后面阶段中进行

●数组必须在初始化之后才能访问，不能进行如下的操作

```
int[] array;
array[10] = 5;
```



## 底层知识点

#### 1、堆和栈：

堆栈空间分配区别：
 　　1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈；
 　　2、堆（操作系统）： 存储复杂类型(对象)，一般由程序员分配释放， 若程序员不释放，由垃圾回收机制回收，分配方式倒是类似于链表。

#### 2、栈和堆栈：

栈和堆栈是一个概念

队列先进先出，在队头做删除操作,在队尾做插入操作。

栈先进后出，在栈顶做插入和删除操作。

堆和它们不同，不存在是先进后出还是先进先出。



​	堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。{堆是指程序运行时申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。}

 	栈是先进后出的，但是对于堆而言却没有这个特性，两者都是存放临时数据的地方。 对于堆，我们可以随心所欲的进行增加变量和删除变量，不要遵循什么次序，只要你喜欢。



# 教材知识点归纳



## 第一章:绪论



### 底层简介(规范+实现)

#### ●公共语言架构(CLI):

​	1)通用类型系统(CTS):定义了一套类型系统的框架

​	2)公共语言规范(CLS):一组语言规则的集合,可以实现跨语言集成

​	3)通用中间语言(CIL):一种中性的,与处理器无关的指令语言.任何.NET程序代码都可以被编译成CIL代码,而CIL代码又可针对不同的系统平台翻译为不同格式的机器指令(二进制代码).

​	4)其他相关的标准化文档,协议,规范等

#### ●.NET Framework:

​	==1)公共语言运行时(CLR):==
​			(1)CLR是一个支撑平台.CLR就是一个虚拟机,它为.NET应用程序提供了一个抽象于底层操作系统和硬件的运		行时环境.

​			(2)主要功能:

​				--管理代码的执行.在程序执行时,CLR将CIL代码翻译为机器指令,负责加载所需的元数据的类型及其他各种		资源,并在执行过程提供安全性管理,错误处理,垃圾回收等服务

​				--提供通用类型系统.

​				--提供系统服务.应用程序不需要和底层操作系统打交道,由CLR为程序提供内存分配,资源请求,设备控制等		操作系统服务

​		===>==CLR是在.Net平台上实现程序高度的互操作性,集成性,可重用性和可移植性的关键所在

​	==2).NET类库==

​			(1)是一个面向对象的类型集合

​			(2)主要内容:

​				--基础类型:整数,实数,字符串,等

​				--数据结构封装,如集合,链表,队列,堆栈等数据类型

​				--Windows和Web等界面要素,主要是按钮,标签,文本框,菜单等可视化控件

​				--..................................

#### ●托管代码

​	1)满足公共语言规范要求,基于CLR编译和运行的程序代码称为托管代码

#### ●非托管代码

​	1)这些代码在CLR环境外部运行,需要自行实现垃圾回收,类型检查,安全性控制服务等服务机制.

​	2).NET平台支持托管代码和非托管代码之间的相互调用



### 程序的基本结构

#### 类型和方法

​	

```
Console.WriteLine("Welcome to .NET!");
```

Console表示控制台对象.这是.NET类库中预定义的一个类,

WriteLine是其一静态方法,用于在控制台中输出一行文本,也叫做成员方法.

==对于预定义:==任何数据类型的顶级父类都是Object,它存储的只是个引用而并不是实际的值,它不像int,float等是语言预定义好的,而枚举,哈希这些是属于结构类型,所以不属于预定类型.

```
static void Main()
{
	Console.WriteLine("");
}
```

在c#程序中,Main方法定义了程序的入口点,因此也叫做程序的主方法.每个c#可执行程序都要从一个Main方法开始执行,而后通过调用其他各种方法来完成所需的程序功能.当执行到Main方法的结尾,程序结束运行.

Main方法属于自定义类Program的成员方法.类使用class关键字定义,其中可以包含数据成员(字段)和函数成员;

方法则是最基本的函数成员.



#### 命名空间

●namespace用于定义命名空间.

●成员必须属于类型,类型又必须属于命名空间,一个命名空间还可以再嵌套在另一个命名空间之间

●元素之间的从属关系在c#中用圆点来表示.

●命名空间的一个重要作用就是解决命名冲突的问题

●如果没有引用命名空间,那么在代码中访问其他命名空间中的元素时就应当使用全名.

#### 程序注释

// /// /**/

#### 程序集

●源代码需要被编译为物理程序之后才能运行.应用程序的基本组织单元叫做程序集.(exe,(动态链接库)dll)

●System.dll程序集是.NET类库里面最基本的一个程序集,定义了一些最为基础的类型.在编译时会被自动引用.

●在c#语言中,return关键字用于返回值,方法代码执行到这里就会结束;只要方法的返回类型不为void,那么执行代码中就必须使用return语句来返回值.

●不包含Main方法的程序不能作为执行程序运行.

#### 控制台交互

Read---返回int类型---从输入流读入下一个字符,直至换行符结束

ReadKey---返回ConsoleKeyInfo---从输入流读入一个字符

ReadLine---返回string---从输入流读入一行文本,至换行符结束

Write---接受参数string---返回void---输出一行文本---有重载

WriteLine---接受参数string---返回void---输出一行文本,并在结尾处自动换行---有重载

#### Windows窗体和WPF窗体

●Windows窗体应用程序包含两个类:

​	含有Main方法入口点的Program类

​	窗体类Form1

●和Form类型不同,WPF窗体都继承自System.Windows程序集中的Window类.



## 第二章:c#数据类型



### 值类型

==值类型包括简单值类型和复合值类型，简单值类型：整数，字符，实数，布尔类型；复合值类型：结构，枚举==

![https://img-blog.csdn.net/20170729110914749?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY1OTYxNDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast](https://img-blog.csdn.net/20170729110914749?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY1OTYxNDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

#### 	整数类型

​	●  sbyte  byte  		 8位

​		short  ushort      16位

​		 int 	 uint 		  32位

​		 long   ulong  	 64位

​	●溢出现象:最大值加一后变为了最小值,最小值减1后变为了最大值

#### 	字符类型

​	●c#采用的是unicode字符集,其中一个字符的长度是16位

​	●c#采用的字符类型是char,赋值时要用单引号把字符括起来.

​	●char c3 = ' \ ' ';

​	●\b	退格	\r	回车	\0	空字符	\f	换页	\t缩进	\n	换行	

​	●char类型其实是一种特殊的整数类型,其取值范围与ushort相同

#### 	实数类型

​	●1)32位单精度实数(float)	64位双精度实数(double)	128位十进制实数(decimal)

​	●float后缀f	decimal后缀m

#### 	布尔类型

​	●布尔类型(bool)的变量取值只能是true或者false

​	==●bool类型在计算机内部以二进制1和0来表示,处理效率很高,但true和false与1和0不存在对应关系==

#### 	结构 

​	●结构类型用于将一组数据组织在一起,它使用关键字struct来定义

​	●new关键字用于创建类型的变量

```
struct Location
{
	public double Longitude;
	public double Latitude;
}
```

```
Location x = new Location();
x.Longitude = 33.3;
```

也可以在创建对象的同时为其一个或多个公有字段进行赋值

```
Location x = new Location(){Longgitude = 33.3;Latitude = 120.5};
```

​	●结构中的成员字段不一定是简单值类型,也可以是其他复合值类型和引用类型.

```
struct Address
{
	public string City;
	public string Street;
	public int Number;
}
struct Contact
{
	public string Name;
	public bool Gender;
	public DateTime Birthday;
	public Address Address;
}
```

多层成员关系是通过多个圆点连接符来访问的

#### 	枚举

​	●枚举类型:复合值类型;enum关键字

```
enum Weekday
{
	Sunday,Monday,Tuesday,Wednesday,Thursday,friday,Saturday
}
```

​	●结构和枚举的不同点:

​		●结构:变量值包含了其所有成员的值

​		  枚举:变量在某一时刻只能取其中某个成员的值.

​		●结构:成员类型可以各不相同

​		  枚举:成员类型都是整数类型.

​	==●访问枚举成员时,圆点连接符之前不是枚举变量名,而应该是枚举类型名==

```
Weekday w1;
w1 = Weekday.Monday;
```

​	●默认情况下,枚举中的第一个成员对应的整数值为0,其后各个成员的整数值依次递增1

​	●超出范围直接输出整数值

### 引用类型

#### 	类

​	●结构和类都是面向对象的类型,是对一组同类对象的抽象描述,不过结构主要用于小型数据结构,类更适用于大多数更为复杂的类型.

​	==●结构和类的区别==

​		●结构值类型,类引用类型

​		●值类型变量     : 直接包含自身所有数据          每创建一个新变量,就在内存中单独开辟一块区域.

​		  引用类型变量  : 只存储对目标数据的引用      每创建一个新变量,就增加一个指向目标数据的指针.

​		●类之间可以存在继承关系,而结构不能.

​	●null值表示空引用,它可以被赋值给任何引用类型的变量,此时引用变量就不指向任何对象.

#### 	数组

##### 一维数组

​	●数组:同一类型变量的有序集合;

​			   初始化之后长度是固定的;

​			   类型可以值类型引用类型;

​			   值类型数据直接存于数组

​		   	引用类型存引用对象地址;

​	●如果数组元素为引用类型,那么在初始化整个数组之后,还要记得初始化各个数组元素

​	

##### 多维数组

规则数组

```
int[,] a = new int[3,4];
int[,] a = new int[,]{{0,0,0,1},{1,1,2,2},{2,3,4,5}};
int[,] a = {{0,0,0,1},{1,1,2,3},{2,3,4,5}};
```

不规则数组

​	●不规则数组的定义需要使用多个中括号,而且对数组进行初始化之后不能忘记对各个子数组进行初始化

```
int[][] b = new int[3][];
b[1] = new int[3];
b[2] = new int[2];
b[3] = new int[4];
```

​	●在不规则多维数组中存储的只是指向各个子数组的地址,即数组的元素完全是引用对象的形式存在的

●Length和getlength

规则数组

```
int[,] a = {{0,0,1,1},{1,1,2,2},{2,3,4,5}};
Console.WriteLine(a.Length);//输出12
Console.WriteLine(a.GetLength(0));//输出3,一维的长度
Console.WriteLine(a.GetLength(1));//输出4,二维的长度
```

不规则数组

​	Length属性返回数组本身的长度(子数组的个数),且各个子数组的长度需要通过每个元素的Length属性来得到.

#### 	字符串类型(最常用的类)

​	●空字符串表示长度为0的字符串对象,而null表示空引用.

​	●访问值为null字符串的Length属性会引发异常

​	●字符串是对一组字符的封装,其很多用法与字符数组类似,最基本的就是通过索引来获取指定位置的字符.

​		不过String类的索引操作是只读的,即不能像数组那样直接修改字符串的某个字符.

​	●字符中任意一段连续的字符称为该字符串的子串

​	●IndexOf和LastIndexOf方法不仅可以查指定字符,还可查找指定子串,返回的是子串的首字符的位置.

​	●StartsWith,EndsWith,Substring,Remove,Insert,Replace和Contain方法均可判定子串

​	●Format方法会对每个参数对象调用ToString方法,而后将各项内容合并到结果中,对于数值类型,在格式化过程中还可以指定参数对象的标准输出格式,这时要在指代标记的数字后加上冒号,后跟标准格式说明符.

#### 	接口

​	●每个接口描述了一个"契约",其中约定了服务方需要提供的一组功能.

​	●接口中的定义的方法只是一个"签名",而没有提供实现代码,只描述要做什么,而不关心怎么做.

​	●对接口类型也不能创建对象

​	●在类和结构的定义中可以声明对某个接口的实现,那么它们就要按照接口的规定提供相应的功能,即为接口方法提供实现代码.对接口的实现声明与继承声明类似.

​	●使用接口的好处:不必去一一检查各个对象的类型所提供的详细功能,而只要判断这些类型是否实现了某个接口.

​	●设一组对象都实现了接口I,那么可以将这些对象都视为I类型的变量.对其统一调用I中规定的操作,而不必关心每个对象的具体类型.

#### 委托



### 类型转换

#### 	数值转换

●指在各种整数,实数以及==字符==类型之间进行的转换

●原则:低精度-->高精度	隐式转换

​		   高精度-->低精度	显示转换

●精度相同的无符号数值类型向有符号数值类型的转换也只能是显示转换

●decimal和double类型之间都要进行显示转换

●从char到ushort可进行隐式转换,结果字符的十进制整数编码

  从ushort到char可进行显示转换,结果指定编码的字符

●从char类型到其他数值类型的转换,可视为先从char到ushort的隐式转换,再从ushort到这些类型的显式或隐式的转换,反之同理.

●所有的隐式转换都可以写成显示转换的形式.

#### 	枚举转换

●自定义的枚举类型在本质上也是整数,但枚举类型和整数类型之间必须使用显式转换,唯一的例外是常数0可以直接赋值给枚举变量.

#### 	引用转换

●类之间	类与接口之间	接口之间	委托之间	数组之间

●委托和数组本质也是通过类实现的

●类之间	类与接口之间

●原则:派生类-->基类	隐式转换

​		  基类-->派生类	显示转换,且不一定成功

​		  如果转换成功,那么两个变量将指向同一个对象

●值类型之间的数组之间不能进行转换

  引用类型之间要求维数相同,且转换方式与数组元素类型之间的转换相同

●任何引用类型的变量都可以转换为object类型,反之则要进行显示转换

#### 	装箱和拆箱转换

●装箱转换是从值类型到引用类型的隐式转换,包括某个值类型到它所实现的接口的显示转换

●拆箱转换是从引用类型到值类型的显示转换.

●只有装过箱的对象才能拆箱

●不影响值,InBox中间对象

●如果被拆箱的Object类型或接口类型的变量为null,那么拆箱转换就会引起程序异常.



## 第三章 值和方法

### 常量和变量

程序处理的数据是内存中的数据,这些数据的表示形式分为常量和变量.

方法用于对数据进行各种操作,方法代码中出现的变量分为局部变量,字段,和参数.

#### 常量

常量即固定的值

字符串类型是一种特殊的引用类型;除了它之外,其他引用类型的常量只有一个,那就是空值null.

#### 变量

●变量是程序中的数据存储单元,每一个变量都是其类型的一个对象,其值在运行时可以被改变.

●变量必须先定义后使用.

●变量一经定义,其类型就不能改变.

●变量的名称必须以字母开头,并由字母,数字,下划线构成,且不能与c#中的关键字或库函数的名称(如using,int,Main)相同

●var:用于隐式变量声明,即在声明变量的时候不用明确指定其类型.

​	如果类型名较长,使用隐式变量声明能够有效简化代码,而且很多时候还能减少对其他命名空间的引用.

​	但一般情况下,过度使用var会影响程序的可理解性

●对于类的变量,要注意未赋值和空值null的区别:空值null已开辟了一块空间.

●对于引用类型的变量而言,如果未赋值就访问其成员 ,那么代码不能通过编译;

  而如果在变量值为null中访问其成员,代码能够通过编译,但在程序运行时会发生异常.

●方法执行到创建变量的代码时就会分配内存,而方法执行完毕后就从内存中清除,因此变量也叫做局部变量.

●一个方法的执行代码中不允许出现两个同名的变量;但不同方法中的变量不会存在命名冲突.



### 字段

#### 实例字段

●在类或结构中定义一般数据成员叫做数据成员

●如果未采用任何一种方式为字段指定初始值,那么在创建对象后,字段将取其类型的默认值,局部变量不同.

●结构中实例字段不能被赋初始值.

●对于所有的整数(包括字符和枚举)类型和实数类型,其默认值为0;布尔类型的默认值为false;而所有的引用类型默认为null.

●和局部变量不同,字段在定义时必须==明确其类型,而不能使用var进行隐式定义.==

●生命周期随对象的创建而开始,随对象的销毁而结束.

●每创建一个类的对象,就在内存中开辟了一块区域用于存储该字段.

#### 静态字段

●实例字段归类型的对象所有.如果在字段定义时再增加一个static修饰符,那么,表示的字段是静态的,它归类型本身所有,而与类型的具体对象无关.

●生命周期从程序中第一次使用到其所属类型开始,直到该类型的所有对象都被销毁才结束.

●类的静态字段为这个类的所有对象所==共享==,无论该类创建了多少个实例,一个静态字段在内存中只有一份存储.

#### 常数和只读字段



### 方法

#### 方法的定义和调用

##### 方法的定义

方法代表了对象所能提供的操作或服务.

定义:返回类型	方法名	一对小括号中的参数列表	一对大括号括起来的执行体

##### 形参和实参

●形参:方法定义中声明的函数

●实参跟形参的类型相同,或者能够隐式转换为形参的类型.

##### 方法的递归调用

●递归调用:调用方法本身

●递归定义的方法应当具备终止条件

#### 参数类型

##### 引用型参数

●ref:参数的传递方式由值类型变成了引用传递

●在调用方法时,引用传递的实参之前也要加ref关键字,这时传递给方法的就不是实参的拷贝,而是指向实参的引用.

●对于引用类型的参数,不使用ref关键字进行参数传递,会使得形参和实参指向同一个内存对象,对形参的修改同样会影响到实参,

  如果使用到了ref关键字,那么,调用时形参就会成为指向实参的引用,

##### 输出型参数

●能执行一次方法得到多个返回值

● 在形参类型前加上一个关键字out

●输出型参数采用引用传递的方式,但和引用型参数不同,输出型参数的形参在方法的执行体中必须被赋值.不管外面.

●而这样的赋值会作用到实参,因为形参和实参指向的是同一引用.

##### 数组型参数

●在每个方法中最多只能定义一个数组型参数,而且该参数必须位于参数列表的最后.

●当方法中使用了数组型参数,且其元素类型为值类型时,如果实参是一个数组变量,则对其采用引用传递;

  如果是一组变量,则对其采用值传递的方式.

●第一次调用方法时以3个整数共同作为实参,其值不会被改变;第二次调用方法时以一个数组作为实参,数组元素的值会被改变.

#### 方法的标识和重载

●方法名和参数列表共同组成了方法的标识.

●方法的返回类型不足以对方法进行标识,即不允许两个方法的名称和参数列表完全相同,而仅仅是返回类型不同

●如果两个方法中的同名参数一个是普通类型,另一个是ref或out类型,那么这两个参数视为不同类型

●如果两个同名参数一个是ref类型,另一个是out类型,她们的区别不足以标识不同的方法.

#### 可选参数和命名参数

●可选参数:允许在方法定义时为参数指定默认值;如果在调用时未指定这些参数值,那么就视这些参数的值为默认值.

```
depublic void Scale(double d1,double d2 de= 1.0)
{
	width = width *d1;
	height = height *d2;
}

```

●为可选参数指定的默认值必须是一个常量表达式

●可选参数不能是引用型或输出型函数

●如果方法中使用了多个可选参数,那么不能省略前面的参数值而去

#### 实例方法和静态方法

●实例方法的执行代码可以直接访问静态成员和非静态成员

●静态方法的执行代码只能直接访问静态成员

==●静态方法访问非静态成员时需要指明其所属的实例==

●如果一个类的成员都是静态成员,那么该类实际上不需要创建对象,此时可使用static修饰符将其定义为静态类.

### 委托和方法的调用

●结构和类的对象都可以作为变量或参数进行传递.

●c和c++是通过指针来封装方法,而c#的实现方式就是委托

●委托步骤:

​	1)定义委托原型

```
delegate bool MyDelegate(decimal x);
```

​	2)创建委托对象

​	即将某个方法作为参数封装到委托对象的创建表达式中,注意参数和返回类型都应与委托原型中的定义完全一致

```
BankCard c1 = new BandCard();
MyDelegate d1 = new MyDelegate(c1.Pay);
//==MyDelegate d1 = c1.Pay;//但是不明了
```

​	3)通过委托对象来调用方法

```
d1(100);
```

●程序里定义的所有委托类型默认是System程序集中Delegate类的派生类.

### 成员访问限制

●信息封装:每个对象负责维护自己的数据信息,对象之间主要通过发送信息进行通信.外部对象要访问其数据信息或与之进行消息通信,必须有足够的访问权限.-->访问修饰符

●public:表示成员是公有的,可以从外部进行访问

●private:表示成员时是私有的,只允许在类型内部进行访问.

●protected:表示成员是保护的,只能被当前类及其派生类中的方法成员访问.

●internal:表示可在程序集内部访问

●上述修饰符中只有protected和internal二者可以同时使用.(在当前程序集中定义的派生类可以访问)

●public	protected	internal	private	访问限制级别由低到高

●私有字段只允许其所属类型的其他方法成员进行访问.

●对于类型中的方法而言,如果需要通过它对外提供服务,即通过对象可以调用该方法,那么它应该定义为公有的

●私有方法的作用通常是封装一部分功能,以供类型中的其他方法调用.

==●如果成员定义中没有指定访问限制修饰符,那么默认是私有的==

## 第四章:操作符和表达式

### 操作符

●表达式由操作数和操作符来组成

●操作符分为一元,二元,三元

●赋值操作符"="优先级最低

●括号具有最高的优先级

●赋值操作符和条件操作符属于右结合的操作符,其他均属于左结合

### 算数表达式

＋ - * / %

#### 基本算数运算

●算数操作符可以作用于整数类型和实数类型,但在使用时注意类型的范围和精度

●整数运算溢出时,超出范围的部分将按相反数处理,而当实数运算超出范围时,结果将会被设置为无穷大(符号取决于操作数的正负)

●当两种不同类型的操作数进行运算时,结果的类型与精度最高的操作数类型相同.

●整数运算不能以0为除数,其中除以0的代码不能通过编译,而除以值为0的变量将引发异常

==●加法和减法操作符还可以作用于字符类型和枚举类型,这时,默认的操作是将字符或枚举值转换为整数值,执行加法和减法运算后再将结果重新转换为字符或枚举==

●对于枚举,如果运算结果超出了枚举定义的整数范围,枚举值依然有效,只是以整数形式来表现.

#### 字符串相加

●c#中的加法操作符可用于字符串的连接

●如果加法运算中只有一个操作数是字符串类型,那么,加法操作会先通过Object类型的ToString方法得到另一个操作数的字符串表示,再将两个字符串连接起来.

```
string s1 = "国庆"+2020;//s1 = "国庆2009"
s1 = 'T'+s1;		   //s1 = "T国庆2009"
```



#### 委托加减

●加法和减法操作符还可以作用于委托类型,这称为委托的合并和删除.

==●任何委托变量加上或减去nul值仍为其本身,在进行委托删除运算时,如果作为减数的委托不在作为被减数的委托中,删除运算不会产生任何效果==

### 自增和自减表达式

++ --	前缀 后缀

### 位运算表达式

●位运算表达式就是对数据按二进制位进行运算

●&	  |	   ^	      ~		<<		>>

●与	或	异或	取补	左移	右移

●只有取补操作符"~"是一元操作符,其他均为二元操作符.位运算不会像算数运算发生溢出

●操作数要求是整数类型,或者是能够转换为整数类型的其他类型

●注意符号问题:如果操作数无符号,则按无符号二进制整数形式运算;否则按有符号二进制整数形式进行运算

●二进制的首位视为符号位(0为正,1为负)

#### 取补运算

●取补运算的操作数限定为int	uint	long	ulong 枚举

●返回类型与操作数类型相同

●sbyte	byte	short	ushort	char也可以参与运算,但之前会被隐式转换为int或uint类型,返回类型也为int或uint.

●取补运算将操作符的二进制每一位取反.

#### 与,或,异或运算

●与,或,异或的操作数限定为int	uint	long	ulong	枚举	布尔

●返回类型与操作数类型相同

●都是对两个操作数的对应二进制位进行逐位运算,若位数不等则加0补齐.

#### 移位运算

●移位运算的左操作数可以是;int	uint	long	ulong这4中整数类型,表示要被移位的整数

●右操作数只能是int类型,表示所移的位数.

●表达式返回类型与左操作数的类型相同.

●左移位:将操作数的二进制位依次左移,左边的高位舍弃,右边的低位顺序补0

●右移位:将操作数的二进制位依次右移,右边的低位舍弃,无符号整数的高位顺序补0;负数则对高位顺序补1.

### 赋值表达式

### 关系表达式

●==	!=	<	>	<=	>=	is

●is操作符用于检查左操作数的类型是否与右操作数兼容

#### 比较运算

●对于值类型,两个操作数是否相等取决于这两个数所包含的值是否相等;

●对于引用类型,两个操作数只有它们指向同一个内存对象或同为空值null时才相等.

●字符串类型string规定两个字符串只要长度相等,并且各位字符对应相等,那么,两个字符串也就相等.

==●>	<	>=	<=用于比较两个数的大小,可以作用于整数类型,实数类型,和枚举类型,但默认情况下不能作用于引用类型==

●对于NAN	c#中认为它不等于任何值,而且两个NAN并不相等.

#### 类型判断

●对于is:e is T

​	如果e的值是null,那么返回false

​	如果e的实际类型是E,且E是T或T的派生类时,返回true,否则返回false

​	T可以是类,也可以是接口.

### 条件逻辑表达式

●只能作用于布尔类型的操作数,且返回值总是布尔类型

●短路:不需要计算整个表达式就可以确定结果

### 其他特殊表达式

#### 一元加减表达式

●一元加号操作符不改变操作数的值,而一元减号操作符去操作数的相反数

#### 条件表达式

●c#中唯一的三元操作符是条件操作符"?:"

●要求后两个操作数的类型兼容

●右关联

#### 类型转换表达式

●as:左操作数是一个变量或表达式,右操作数是一个类型(和is操作符一致)

​		只能进行引用类型的转换或装箱转换,而不能在两个值类型之间进行转换.

​		它能够在类型兼容时将左操作符隐式转换为右操作数指定的类型,而在类型不兼容时返回空值null

#### 创建表达式

●new操作符用于创建类型的实例或对象

●new	T()	T可以是一个结构,也可以是一个类.

​	

## 第五章:流程控制

### 选择结构

#### if语句

●if语句是根据布尔类型的表达式来选择要执行的语句

#### switch语句

●switch语句是根据一个表达式的多个取值来选择要执行的代码段.

==●switch语句总是可以使用if语句来替换.如果控制表达式的取值范围较小且离散分布明显,则使用switch语句==

  ==如果其范围较大且成区间分布,则使用if语句,有利于简化程序.==



### 循环结构

#### while循环语句

#### do-while循环语句

#### for循环语句

#### foreach循环语句

### 跳转结构

#### break语句

●break语句只能跳出选择或循环结构的当前嵌套层次

#### continue语句

●break语句能够结束整个循环,而continue只能跳过当前循环中尚未执行的代码,并继续开始下一循环

#### return语句

●return语句用于方法的返回

#### goto语句

●goto语句用于程序指令的无条件跳转



## 第六章:深入理解类

### 面向对象的方法学

#### 对象

●软件对象是对现实生活中的对象的抽象描述.

#### 类

●是指一组具有相同数据结构和相同操作对象的集合,是对一系列具有相同性质的对象的抽象,它描述的不止单个对象而是群体对象的共同特征.

#### 继承

●是指以现有类型定义为基础来创建新类型的技术.

#### 通信

对象具有自治性和独立性.但对象与对象之间又不是彼此孤立的,他们通过消息进行通信,从而相互协作来共同完成任务.

### 构造函数和析构函数

#### 构造函数

●构造函数在每次创建对象时被自动调用.名称和类名相同.

●构造函数不声明返回类型,而且声明中没有void关键字

●只有公有属性的构造函数才能用于创建对象

●构造函数只能对对象进行初始化(字段值的设置),而不能进行其他操作,比如输入输出.

●构造函数只能在创建对象的时候被自动调用,而不能被对象显式调用.

●不带任何参数的构造函数称为默认构造函数.

●如果没有进行显式创建构造函数,系统也会默认提供一个构造函数,没有参数也没有执行代码,只负责创建对象,而不进行其他初始化的操作

●如果一个类中只定义了私有或受保护的构造函数,那么不能用new关键字来创建实例.

#### 析构函数

```
~Account(){}
```

●析构函数没有任何参数和返回值,也不能使用任何访问限制修饰符.

●析构函数的代码通常只用于释放资源,而不应执行其他操作

#### 静态构造函数

●属于类而不属于类的对象

●用于对类的静态字段进行初始化,在程序中第一次用到某个类时,静态构造函数自动被调用,而且是仅此一次.

●静态构造函数不能有任何参数和访问限制修饰符

### 属性

 ●set访问函数进行赋值操作,它包含一个隐式定义的参数value,表示要传递给属性的值.无论是get访问函数的返回值还是传递给set访问函数的value参数值,其类型都应与属性所声明的数据结构保持一致.

●属性和字段的根本区别在于它并不实际存储变量的值.因此,对象的属性并不能作为ref或out类型的参数传递给其他方法.

●自动属性必须同时包含get和set访问函数,其次是自动生成的字段是完全隐藏的,不能在代码中直接访问.

### 索引函数

●以数组的方式来控制多个字段的读写访问

●索引函数以this关键字加数组下标[]进行定义,并通过数组下标的形式进行访问

●索引函数的get和set访问函数有一个专门的参数来表示数组下标

●索引函数不能是静态的

```
private decimal[] moneys;
public decimal this[int i]
{
	get
	{
		return moneys[i];
	}
	set
	{
		moneys[i] = value;
	}
}
```



### 事件

●处理事件

1)定义一个委托原型

```
delegate void BookHandler(string book);	//事件原型
```

​	==引发事件==:委托是对方法的封装,那么发布者在特定的情况下调用委托所封装的方法的行为.

2)定义该委托类型的事件成员

```
class BookStore
{
	public event BookHandler OnNewBook;	//定义一个事件
	public void NewBook(string book)
	{
		OnNewBook(book);
	}
}
```

​	其他类型如果要订阅事件,就要定义自己的事件处理方法,并将这些方法合并到发布者的事件成员中(添加).

```
class Customer
{
	private string _name;
	
	public Customer(string name)
	{
		_name = name;
	}
	void store_OnNewBook(string book)
	{
		Console.WriteLine("{0}您好:书店新到新书<{1}>",_name,book);
	}
	public void Register(BookHandler store)
	{
		store.OnNewBook += new BookHandler(store_OnNewBook);
	}
}

```

主函数

```
BookStore store = new BookStore();
Customer c1 = new Customer("张三");
Customer c2 = new Customer("李四");
c1.Register(store);					//订阅了这家书店微信公众号
c2.Register(store);					
store.NewBook("giao");				//书店有新书了,发布了新事件
```



### 操作符重载

●操作符重载要使用operator关键字,后跟要重载的操作符.

●被重载的操作符也是一种特殊的方法,且必须声明为公有的和静态的.

●在重载定义中,一元操作符的参数类型应为当前类型或是可以隐式转换为当前类型.

  						二元操作符则至少有一个参数类型应当为当前类型或是可以隐式转换为当前类型.

==●重载和重写的区别==

​	https://www.runoob.com/java/java-override-overload.html



### this关键字

●在非静态的函数成员中可以使用this关键字,表示**对当前对象的引用**

●允许方法的参数和代码中的局部变量与字段重名,那么在访问字段时就就必须加上this引用.

●可以将对象作为参数传递给其他方法.

### 几个常用类

●Math类

●StringBuilder类

​	方便对同一个字符串的频繁操作.

ArrayList类

## 第七章:继承和多态性

### 继承

#### 基类和派生类

●基类拥有一般性的特征,派生类在拥有基类的基本特征之外,自己还有更为具体的特征

●不允许多继承,只有在类和接口之间可以实现多继承.

**●System.Object类是其他所有类的基类**

#### 隐藏基类成员

●增加一个new关键字进行修饰,表示该方法隐藏了(覆盖)基类中的同名方法.

#### base关键字

●base关键字用于访问基类的成员,

●*在继承基类中不带参数的默认构造函数时,派生类的构造函数定义中不必写出base关键字,但在构造派生类对象时仍然会自动调用基类的构造函数.*

==●如果基类定义了带参数的构造函数,派生类的构造函数就必须通过base关键字来指明继承哪一个基类构造函==

==数.==

==●当派生类成员隐藏了基类成员,通过base关键字引用的成员为基类成员,通过this关键字引用的成员为派生类成员==

#### 对象声明周期

**●对于派生类而言,对象在创建时将自顶而下地调用各级基类的构造函数,最后调用自身的构造函数.**==销毁时首先调用自己的析构函数,而后自下而上地调用各级基类的析构函数==

### 多态性

●多态性:同一事物在不同条件下可以表现不同的形态.

#### 成员的虚拟和重载

**●派生类可以隐式转换为基类对象**

●在基类中使用关键字virtual修饰的方法叫作虚拟方法,在派生类中定义同名的方法时,使用关键字override修饰的方法叫作重载方法,它在运行时会根据对象的实际类型来进行调用.

●父类实例赋值给子类实例:

​	https://www.jb51.net/article/5531.htm

 ●如果在派生类中使用override关键字定义了重载方法,那么也就允许了该类之后的派生类继续重载这一方法.

●在基类中定义虚拟方法,实际上暗示了希望在派生类中继承并重载实现该方法,因此虚拟方法不能是私有的

==●派生类对重载的访问限制应与基类中的虚拟方法相同.==

#### 抽象类和抽象方法

●抽象类:存在抽象概念,它们本身没有具体的对象,只有派生类对象才是真实存在的.

●抽象类通过关键字abstract来进行修饰,==其中的方法如果能够提供实现代码,那么可以写成虚拟方法;如果不能提供,那么可以只给出方法的声明.为抽象方法.==

==●抽象类的子类也可以是抽象类.但如果某个非抽象类继承了一个抽象类,他就必须为抽象类中的所有抽象方法提供实现代码,==

==●包含抽象方法的类必须是抽象类.==

==●抽象类不能创建对象==,但**抽象类可以有构造函数**,其作用是为了方便派生类的继承.

●抽象方法也可以看作是无执行体的特殊虚拟方法,派生类中对抽象方法的重载也通过override关键字进行

●除了一般方法外,属性,索引函数和事件这些函数成员也可以是抽象的或虚拟的.

#### 密封类密封方法

●密封类不能再有派生类,因此密封类总是位于类的继承层次树的叶结点.比如string

●使用关键字sealed修饰

●类似还有密封方法(重载完不希望派生类继续重载)

●密封方法中sealed和override必须同时出现.

**●密封方法所在的类不一定要是密封类,(抽象类相反)**,而且其派生类中仍然可以使用new修饰符来隐藏该方法.

●如果类的继承和方法的重载层次过深,将会占用大量的内存堆栈.而密封类和密封方法能够避免或简化动态判断的过程,有助于程序综合性能的提高.

### 接口与继承

#### 接口和抽象类

●相同点:**接口和抽象类都不能被实例化,接口方法和抽象类中的抽象方法都不提供实现代码.**

●接口的抽象程度比抽象类更高.

●不同点:**抽象类中既可以有抽象方法,也可以有非抽象方法,还可以有自己的字段成员;**

​			   **接口不包含任何数据和方法实现代码**

#### 接口方法的实现

##### 隐式实现

```
public interface ISaleTicket
{
	decimal GetPrice(int a);
}
public class Cinema:ISaleTicket
{
	public decimal GetPrice(int a)
	{
		return a;
	}
}
```

##### 显式实现

```
public class Agent:ISaleTicket
{
	decimal ISaleTicket.GetPrice(int a)
	{
		return a;
	}
}
```

​	●显式实现的接口方法不能有任何修饰符,实际上就是类型的私有成员.该方法不能通过类型的对象来访问.

​		将其转换为接口类型后就可以调用该方法

```
Agent agent = new Agent();
Console.WriteLine((agent as ISaleTicket).GetPrice(10));
```

●类型中还可以对一个接口方法同时进行隐式实现和显示实现.

#### 基于接口的多继承

●类之间只能进行单继承,而==接口之间以及类和接口之间可以进行多继承==

●解决二义性:(基类和多个父接口可能会具有相同的成员)

​	●派生类可以用一个方法来重载或实现基类及接口中的所有同名方法.

```
public interface IA
{
	void F();
}
public interface IB
{
	void F();
}
public class CA
{
	public virtual void F()
	{
		Console.WriteLine("F method of class CA");
	}
}
public class CB:CA,IA,IB
{
	public override void F()
	{
		Console.WriteLine("F method of class CB");
	}
}
```

​	但有时候希望派生类提供多种不同的方法实现,以便将派生类转换为不同的基类或接口类型后能调用不同的方法,

这时候就要用到对接口的显式实现



### 拓展方法

