using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace _02数据类型与转换
{
    class Program
    {
        static void Main(string[] args)
        {
            #region  基础知识点
            /*
                c#标识符命名规则:
                    1)所有的标识符只能由字母,数字,和下划线这3类字符组成.且第一个字符必须为字母或下划线
                    2)标识符中不能包含空格,标点符号,运算符等其他符号
                    3)标识符严格区分大小写
                    4)标识符不能与c#关键字名相同
                    5)标识符不能与c#中的类库名相同

                数据类型: 值类型 引用类型
                值类型:结构体 枚举 简单类型
                    值类型的变量内含变量值本身
                引用类型:类 数组 接口 委托   
                    引用类型也称参考类型,引用类型的变量不存储所包含的值,而是指向它所要存储的值,类似指针
                简单类型:字符型 整形 布尔型 实数 
                整型:sbyte byte short ushort int uint long ulong 
                实数:float double decimal
                
                默认值：字符型：char /u0000
                如果引用数据类型是存放于堆内存中的话，即使你没有给他赋值，jvm也会对其初始化，即空引用，
                表示不指向任何堆内存的地址

                整数类型:
                    1)字节型(8位):sbyte byte
                    2)短整型(16位):short ushort
                    3)整型(32位):int uint
                    4)长整型(64位):long ulong

                实数类型:
                    1)单精度(32位):float


                    2)双精度(64位):double
                    3)十进制(128位):decimal
                    4)正无穷大:Positive Infinity
                    5)负无穷大:Negative Infinity
                    6)非数字:NAN
                布尔类型:
                    1)true:真值
                    2)false:假值
                    bool bt = (bool)1       错误

                字符与转义:
                    \' \" \\ \0 \a \b \f \n \r \t \v


                结构
                结构类型的声明:
                    结构类型由若干"成员"组成的.数据成员成为字段,每个字段都有自己的数据类型.
                结构变量的使用
                    1)访问结构变量字段
                        格式  结构变量名.字段名
                    2)结构变量的赋值
                        结构变量的字段赋值:使用方法和普通变量相同
                        结构变量之间的赋值:要求赋值的两个结构变量必须类型相同
                        s1 = s2
                        s2所有的字段值赋值给s1的对应字段



                类与对象

                    类是一个样板,以操作,表示和算法的形式完整地定义了一组对象的行为.它通常是面向对象语言中的模块化
                封装和数据抽象的基础(类-->对象(具体化))
                    
                    对象是类的一个实例,是一个软件单元,它由一组结构化的数据和在其上的一组操作构成
                    类的成员:
                        数据成员:字段
                        方法成员:
                            普通方法
                            构造函数和析构函数
                            属性
                            索引函数


                            事件
                            操作符
                    类:c#所有的代码都是在某一个类中,因此不可能在类之外的全局区域有变量和方法
                    对象:c#中的对象相当于一块内存区域,保存对象特有的类中所定义的数据


                    引用类似于c++中的对象指针.但又有区别:
                    1)在c#中"引用"是指向一个对象在内存中的位置,在本质上是一种带有很强的完整性和安全性的限制的指针
                    2)当声明某个类,接口或数组类型的一个变量时,变量的值总是某个对象的引用或者时null引用
                    3)指针就是简单的地址而已,而引用除了表示地址之外,还是被引用的数据对象的缩影,可以提供其他信息
                    4)指针可以有++,-运算,引用不可以运算


                    所有的东西都是对象:变量和方法的集合
                    初级特性:最基本的概念:即类和对象
                    中级特性:最核心的概念:即封装,继承和多态
                    高级特性:由初级特性和中级特性引出的一些问题,如构造函数的使用,覆盖的规则,静态变量和函数等


                    数组
                        1)数组是同一数据类型的一组值
                        2)数组属于引用类型,因此存储在堆内存中
                        3)数组元素初始化或给数组元素赋值都可以在声明数组时或在程序的后面阶段中进行

                    值类型：
                        1）表示实际数据
                        2）只是将值存放在内存中
                        3）值类型都存储在堆栈中
                        4）int char 结构
                    引用类型：
                        1）表示指向数据的指针或引用
                        2）包含内存堆中对象的地址
                        3）为null，则表示未引用任何对象
                        4）类，接口，数组，字符串

                    值类型存储在运行栈，引用类型存储在托管堆

                    类型转换：
                    数值转换：值类型<->值类型
                        低精度类型->高精度类型:隐式转换
                        高精度类型->低精度类型:显示转换

                    类型转换:枚举转换:枚举<->整数
                        Weekday w1 = 0;  隐式转换
                        Weekday w2 = (Weekday)6; 显示转换
                    引用转换:引用类型<->引用类型
            */
            #endregion

            #region 两个引用指向同一个对象 实例
            //        Student xiaoMing = new Student();
            //        Student xiaoFang = xiaoMing;
            //        xiaoMing.gender = 'M';
            //        xiaoFang.gender = 'F';
            //        Console.WriteLine(xiaoMing .gender );
            //        Console.ReadKey();
            //    }
            //}
            //public class Student
            //{
            //    public char gender;
            //}
            #endregion

            #region tryparse
            //bool a = int.TryParse(Console.ReadLine(), out int b);
            //Console.WriteLine(b);
            //Console.WriteLine(a);
            //Console.ReadKey();
            #endregion

            #region 结构和枚举
            /*
                 首先，结构和枚举是值类型，对于结构和枚举的理解，需要对内存模型有一个很好的认识，众所周知，
             所有的类型分为值类型和引用类型，那么到底是值类型效率好还是引用类型效率好，为什么内存结构演化到
             今天任何一门语言的内存都有堆和栈的存在了
                 值类型中有三种数据类型，结构、枚举、简单数值类型，首先，我们来看结构，结构类型是一个轻量级
             的数据类型，一般用于存储简单的数据对象。注意，轻量级不等同于性能就好，结构和类相比，在不同的情况下
             各自有各自的性能优势，不能一概而论。（结构类型在传参和拷贝的时候性能不如类）结构默认继承自System
             .ValueType,即默认为值类型,通过IL代码里面均为Class,此时内存还没有进行分配,从内存结构上暂时还
             无法进行区分,那么什么时候进行区分了,这就是运行时,即当代码执行的时候会进行区分,那么执行的时候是根据
             什么来进行区分的,根据就是,只要继承自System.ValueType的就是值类型,这里有个很有意思的事情,System.
             ValueType本身是一个引用类型,它是一个抽象类,继承于他的类型是值类型,同时它也有一系列的成员,这就是
             意味着结构也拥有这些成员,有趣的是她所拥有的成员和System.Object是一样的,只不过是对System.ValueType
             中的几个虚函数进行了重写,这一点也说明System.ValueType继承自System.Object,现在我们又知道了所有值类型
             均继承自System.ValueType,但是在定义的时候并不能进行显式的指定,当然更不能指定其他的类型.但是可以支持
             接口,总而言之,结构不能继承自除System.ValueType以外的其他类,同时也不能被其他类继承,因此面向对象的两大
             性质,继承和多态的特性她就没有了,没有了这两大特性,在使用的时候就会收到很大的限制.

             */
            #endregion

            #region 枚举的优点和缺点

            /*
                枚举的优点:
                    1)枚举常量更简单安全:
                        枚举常量只需定义枚举项,不需要定义枚举值,而接口常量或类常量必须定义初始值
                    2)枚举常量稳定
                        在编译期限定类型,不允许发生越界
                    3)枚举具有内置方法
                    4)解决意义不明确,代码更优雅
                        a:调试程序时,想输出性别男,结果输出了0,不是自己写的完全不知道其意义,用枚举类型就完美解决了
                        b:一些的程序里面,可能要用到成百上千的静态常量,如果全在一个文件里面,容易造成命名混淆,程序读起来
                          也比较麻烦
                    5)定义自己的类型
               枚举的缺点:
                    不可继承,无法拓展,但是一般常量在构件的时候就定义完毕了,不需要拓展
            */
            #endregion

            
        }
    }
}